{
    "deviceProfile": {
        "name": "ELSYS-ABP",
        "macVersion": "1.0.3",
        "supportsJoin": false,
        "rfRegion": "AU915",
        "rxDataRate2": 8,
        "rxFreq2": 923000000,
        "payloadCodec": "CUSTOM_JS",
        "payloadEncoderScript": "",
        "payloadDecoderScript": "function Decode(fPort, bytes, variables) {\n  var payload = {};\n  for(var i = 0; i < bytes.length; ){    \n    //TODO: offset usage\n    var offset = bytes[i] >> 6;\n    var type = bytes[i] & 63;\n    i++;\n    switch(type){\n      case 1: //temperature\n        payload.temperature = ((((bytes[i] << 8) & 0x7fff) | (bytes[i+1])) * (((bytes[i] >> 7) & 0x01) ? -1 : 1)) / 10;;\n\t\ti += 2;\n        break;\n      case 2: //humidity\n        payload.humidity = bytes[i];\n        i += 1;\n        break;\n      case 3: //acceleration\n        payload.acceleration = {};\n        payload.acceleration.x = (bytes[i+0] & 0x7F) * (bytes[i+0] >> 7 === 1 ? -1 : 1);\n        payload.acceleration.y = (bytes[i+1] & 0x7F) * (bytes[i+1] >> 7 === 1 ? -1 : 1);\n        payload.acceleration.z = (bytes[i+2] & 0x7F) * (bytes[i+2] >> 7 === 1 ? -1 : 1);\n        i += 3\n        break;\n      case 4: //light\n        payload.light = (bytes[i] << 8) | (bytes[i+1]);\n        i += 2;\n        break;\n      case 5: //motion\n        payload.motion = bytes[i];\n        i += 1;\n        break;\n      case 6: //CO2\n        payload.co2 = (bytes[i] << 8) | (bytes[i+1]);\n        i += 2;\n        break;\n      case 7: //voltage\n        payload.voltage = ((bytes[i] << 8) | (bytes[i+1])) / 1000;\n        i += 2;\n        break;\n      case 0x0A: //pulses\n        payload.pulses = (bytes[i] << 8) | (bytes[i+1]);\n        i += 2;\n        break;\n      case 0x0B: //pulses Absolute\n        payload.pulsesAbs = (bytes[i] << 24) | (bytes[i+1] << 16) | (bytes[i+2] << 8) | (bytes[i+3]);\n        i += 4;\n        break;\n      case 0x0D:\n        payload.digital = (bytes[i] === 1);\n        i += 1;\n        break;\n      case 0x0E: //distance\n        payload.distance = ((bytes[i] << 8) | (bytes[i+1]));\n        i += 2;\n        break;\n      case 0x15: //sound\n        payload.sound = {\n        \tpeak: bytes[i],\n          \tavg: bytes[i+1]\n        };\n        i += 2;\n        break;\n      case 0x1C: //voc\n        payload.voc = ((bytes[i] << 8) | (bytes[i+1]))\n        i += 2;\n        break;\n      case 0x3D: //debug info\n        i += 4;\n       \tbreak;\n      case 0x3E: //sensor settings //TODO:\n        i = bytes.length;\n        break;\n    }\n  }\n  return payload;\n}"
    }
}
